#!/usr/bin/env -S deno run --allow-read --allow-write --allow-net
import { readLines } from "https://deno.land/std@0.224.0/io/mod.ts";
import { Command } from "https://deno.land/x/cliffy@v1.0.0-rc.4/command/mod.ts";
import { Select } from "https://deno.land/x/cliffy@v1.0.0-rc.4/prompt/mod.ts";
import supabase from "../src/libs/supabase.js";
import _ from "../src/libs/atomic_/core.js";
import $ from "../src/libs/atomic_/shell.js";
import g from "../src/libs/game_.js";

const $state = $.atom(null);
const demo = _.str(_.uids(12)());

function log(obj){
  $.log(Deno.inspect(obj, { colors: true, compact: true, depth: Infinity, iterableLimit: Infinity }));
}

function logs(arr){
  for(const obj of arr) {
    _.isArray(obj) ? logs(obj) : log(obj);
  }
}

async function load(table_id, filename, cache){
  try {
    await Deno.stat(filename); // throws if not found
    const text = await Deno.readTextFile(filename);
    const [table, seated, config, evented] = JSON.parse(text);
    return [table, seated, config, evented];
  } catch (err) {
    const resp = await supabase.rpc('shell', {_table_id: table_id});
    if (resp.error) {
      console.error(error);
      Deno.exit(1);
    }
    const text = resp.data;
    const {evented, seated, table} = text;
    const {id, slug, game_id, release, config} = table;
    const data = [{id, slug, game_id, release}, seated, config, evented];
    if (cache) {
      await Deno.writeTextFile(filename, JSON.stringify(data));
    }
    return data;
  }
}

function component({slug, release}){
  return import(`../src/games/${slug}/table/${release}/core.js`);
}

function asCount(v, n = 1) {
  if (v === true) return n;
  if (typeof v === "number") return v;
  if (typeof v === "string" && v.trim() !== "") return Number(v);
  return undefined;
}

function parseJsLikeObject(txt) {
  try {
    return Function(`"use strict"; return (${txt});`)();
  } catch (err) {
    console.error("Failed to parse --cmd object:", err.message);
    Deno.exit(2);
  }
}

async function loadCmdsFile(path) {
  try {
    const text = await Deno.readTextFile(path);
    return text
      .split(/\r?\n/)
      .map(l => l.trim())
      .filter(Boolean)
      .map(parseJsLikeObject);
  } catch (err) {
    console.error(`Failed to read --cmds file "${path}":`, err.message);
    Deno.exit(2);
  }
}

function normalizeList(vs) {
  if (!vs) return [];
  const arr = Array.isArray(vs) ? vs : [vs];
  return arr
    .flatMap(s => String(s).split(","))
    .map(s => s.trim())
    .filter(Boolean);
}

const LENS_ALLOWED = new Set(["game", "event", "effects", "perspective", "prompts", "state", "timeline", "moves"]);

function resolveLens(withList, withoutList) {
  const lens = new Set(["timeline", "perspective"]); // defaults
  for (const w of withList) if (LENS_ALLOWED.has(w)) lens.add(w);
  for (const wo of withoutList) lens.delete(wo);
  return Array.from(lens);
}

function init(make, seats, config, seen, evented, hash, lens, lookback, lookahead){
  const jnl = _.reduce(function(memo, event){
    return _.fmap(memo, g.fold(_, event));
  }, _.journal(make(seats, config)), evented);
  const init = {jnl, seen, lens, lookback, lookahead};
  return {...init, init};
}

function play(seat) {
  return function(...commands){
    return function(memo){
      return _.update(memo, "jnl", _.reduce(function(memo, command){
        return _.fmap(memo, g.execute(_, command, seat));
      }, _, commands));
    }
  }
}

function reset(){
  return function({init}){
    return {...init, init};
  }
}

function flush(){
  return _.update(_, "jnl", _.flush);
}

function undo(){
  return _.update(_, "jnl", _.undo);
}

function redo(){
  return _.update(_, "jnl", _.redo);
}

function to(id){
  //TODO
  return _.update(_, "jnl", function(jnl){
    const idx = _.detectIndex(function(game){
      const event = _.chain(game, g.events, _.last);
      return event.id === id;
    }, jnl.history);
    return _.nth(jnl, idx);
  });
}

function chooseEvent(game){
  const events = g.events(game);
  return Select.prompt({
    message: "Choose an event",
    options: _.toArray(_.concat([{name: "None", value: -1}], _.mapIndexed(function(i, event){
      const {id} = event;
      return {name: JSON.stringify(event), value: id};
    }, events)))
  });
}

function head(){
  return _.update(_, "jnl", _.nth(_, 0));
}

function tail(){
  return _.update(_, "jnl", _.nth(_, Infinity));
}

function listMoves({jnl}){
  return _.chain(jnl, _.deref, g.moves, _.compact, _.toArray);
}

function chooseMove(state){
  const choices = listMoves(state);
  return _.fmap(Select.prompt({
    message: "Choose a move",
    options: _.toArray(_.concat([{name: "None", value: -1}], _.mapIndexed(function(idx, cmd){
      return {name: JSON.stringify(cmd), value: idx};
    }, choices)))
  }), _.nth(choices, _));
}

function timeline(lookback, lookahead){
  return function(jnl){
    const curr = _.deref(jnl),
          latest = jnl.history[0];
    const history = g.events(curr);
    const n = _.count(history);
    const future = _.chain(latest, g.events, _.drop(n, _), _.toArray, _.take(lookahead, _), _.toArray);
    const past = _.chain(history, _.butlast, _.reverse, _.toArray, _.take(lookback, _), _.reverse, _.toArray);
    const present = _.last(history);
    return {past, present, future};
  }
}

function perspective(seen){
  return function(jnl){
    return _.chain(jnl, _.deref, g.perspective(_, seen));
  }
}

function effects(seen){
  return function(jnl){
    debugger
    const {pos} = jnl;
    const [curr, prior] = _.revision(jnl, pos);
    return g.effects([curr, prior, seen]);
  }
}

function look({jnl, seen, lens, lookback, lookahead}){
  const keys = {
    game: _.deref,
    prompts: prompts,
    timeline: timeline(lookback, lookahead),
    effects: effects(seen),
    perspective: perspective(seen),
    event: _.pipe(_.deref, g.events, _.last),
    moves: _.pipe(_.deref, g.moves, _.compact, _.toArray),
    state: _.pipe(_.deref, _.deref)
  }
  return _.reduce(function(memo, key){
    const f = _.get(keys, key);
    return _.assoc(memo, key, f(jnl));
  }, {}, lens);
}

function state({jnl}){
  return _.chain(jnl, _.deref, _.deref);
}

function prompts({jnl}){
  return _.chain(jnl, _.deref, _.plug(g.prompts, _, {}));
}

async function command(run){
  await requestCommand();

  for await (const line of readLines(Deno.stdin)) {
    try {
      switch (line.trim()) {
        case "move":
        case "m":
          const cmd = await _.chain($state, _.deref, chooseMove);
          _.maybe(cmd, run);
          break;

        case "reset":
          $.swap($state, reset());
          break;

        case "game":
          _.chain($state, _.deref, _.get(_, "jnl"), _.deref, log);
          break;

        case "undo":
        case "u":
          $.swap($state, undo());
          break;

        case "redo":
        case "r":
          $.swap($state, redo());
          break;

        case "flush":
          $.swap($state, flush());
          break;

        case "head":
        case "h":
          $.swap($state, head());
          break;

        case "tail":
        case "t":
          $.swap($state, tail());
          break;

        case "moves":
          _.chain($state, _.deref, listMoves, logs);
          break;

        case "state":
        case "s":
          _.chain($state, _.deref, state, log);
          break;

        case "perspective":
        case "p":
          _.chain($state, _.deref, perpective, log);
          break;

        case "prompts":
          _.chain($state, _.deref, prompts, $.log);
          break;

        case "at":
          const id = await _.chain($state, _.deref, _.get(_, "jnl"), _.deref, chooseEvent);
          if (id) {
            $.swap($state, _.pipe(to(id), flush()));
          }
          break;

        case "exit":
        case "quit":
        case "q":
          return;

        default:
          run(line.trim()); //everything else is a command for the game
          break;
      }

    } catch (ex) {
      $.error(ex.message);

    } finally {
      await requestCommand();
    }
  }
}

async function requestCommand(){
  log({commands: "p/erspective, s/state, m/ove, moves, game, prompts, u/ndo, r/edo, flush, h/ead, t/ail, moves, at, reset, exit, q"});
  const encoder = new TextEncoder();
  await Deno.stdout.write(encoder.encode("> "));  // prompt again after output
}

await new Command()
  .name("tablejam")
  .version("0.7.0")
  .description("Boot table state and simulate a game.")
  .arguments("<table:string>")
  .option("--seen <value:string>", "Repeatable or comma-separated list.", { collect: true })
  .option("--seat <number:number>", "Seat index (int).", { default: null })
  .option("--at [id:string]", "Operate at a specific id.")
  .option("--cache", "Cache fetched table state to table-<table>.json.")
  .option("--drop [count:number]", "Drop last N entries (bare flag = 1).")
  .option("--moves", "Show available moves.")
  .option("--move", "Prompt to choose and execute a move.")
  .option("--prompts", "Show prompts for the current game state.")
  .option("--cmd <object:string>", "Execute a move from a command object, e.g. '{type:\"commit\"}'.")
  .option("--cmds <file:string>", "Execute moves (one command object per line) from a file.")
  .option("--with <value:string>", "Add to lens (repeatable or CSV).", { collect: true })
  .option("--without <value:string>", "Remove from lens (repeatable or CSV).", { collect: true })
  .option("--lookback, -b <count:number>", "How many past items to include (default = Infinity).", { default: Infinity })
  .option("--lookahead, -a <count:number>", "How many future items to include (default = 1).", { default: 1 })
  .option("--silent", "Suppress initial output.")
  .option("-i, --interactive", "Keep the program open for further input.")
  .action(async function(opts, table_id) {
    const drop = asCount(opts.drop);
    const atProvided = "at" in opts;
    const at = opts.at === true ? null : opts.at ?? null;
    const seat = opts.seat == null ? null : Number(opts.seat);
    const silent = !!opts.silent;
    const interactive = !!opts.interactive;
    const cache = !!opts.cache;
    const moves = !!opts.moves;
    const move = !!opts.move;
    const prompts = !!opts.prompts;
    const seen = normalizeList(opts.seen);
    const withList = normalizeList(opts.with);
    const withoutList = normalizeList(opts.without);
    const lens = resolveLens(withList, withoutList);
    const filename = `table-${table_id}.json`;

    const cmds = [
      ...(opts.cmd ? [parseJsLikeObject(opts.cmd)] : []),
      ...(opts.cmds ? await loadCmdsFile(opts.cmds) : [])
    ];

    const lookback = opts.lookback === Infinity ? Infinity : Number(opts.lookback);
    const lookahead = Number(opts.lookahead);

    _.chain({table_id, filename, at, atProvided, drop, cmds, seen, seat, lens, lookback, lookahead, cache, prompts, moves, move, silent, interactive},
      //$.see("payload"),
      main);
  })
  .example("Defaults", `tablejam ${demo}`)
  .example("Lens add/remove", `tablejam ${demo} --with state,moves --without event`)
  .example("Temporal scope", `tablejam ${demo} -b 5 -a 2`)
  .example("Commands", `tablejam ${demo} --cmd '{type:\"commit\"}' --seen 0,1 --seen 0`)
  .parse(Deno.args);

async function main(args) {
  const [table, seated, config, evented] = await load(args.table_id, args.filename, args.cache);
  const {make} = await component(table);
  const seats = seated;
  const seen = _.seq(args.seen) ? args.seen :_.toArray(_.range(0, _.count(seats)));
  const hash = args.at;
  const run = _.comp($.swap($state, _), play(args.seat));

  //$.log(`\x1b]0;tablejam:${table.slug} @ ${table_id}\x07`);

  $.reset($state, init(make, seats, config, seen, evented, hash, args.lens, args.lookback, args.lookahead));

  if (args.atProvided) {
    const id = args.at == null ? await _.chain($tate, _.deref, _.deref, chooseEvent) : args.at;
    if (id) {
      $.swap($state, _.pipe(to(id), flush()));
    }
  }

  if (args.drop) {
    $.each(function(){
      $.swap($state, undo());
    }, _.range(0, args.drop));
    $.swap($state, flush());
  }

  const $look = $.map(look, $state);

  $.sub($look, _.drop(args.silent ? 1 : 0), log);

  $.each(run, args.cmds);

  if (args.moves) {
    _.chain($state, _.deref, listMoves, log);
  }

  if (args.move) {
    const cmd = await _.chain($state, _.deref, chooseMove);
    _.maybe(cmd, run);
  }

  if (args.prompts) {
    _.chain($state, _.deref, prompts, $.log);
  }

  if (args.interactive) {
    await command(run);
  }
}
